<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teams Red Light - ESP32 Flasher</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #d73502;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .step {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        
        .step h3 {
            color: #333;
            margin-top: 0;
        }
        
        .step.active {
            border-color: #d73502;
            background-color: #fff5f5;
        }
        
        .step.completed {
            border-color: #28a745;
            background-color: #f8fff8;
        }

        /* New simplified layout styles */
        .version-info {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .version-info h3 {
            color: #d73502;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .main-actions {
            background: #fff;
            border: 2px solid #d73502;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .main-actions h3 {
            color: #d73502;
            margin-top: 0;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .primary-action {
            background: linear-gradient(135deg, #d73502, #b12d02);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(215, 53, 2, 0.3);
        }

        .primary-action:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(215, 53, 2, 0.4);
        }

        .primary-action:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .advanced-section {
            margin: 30px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .advanced-section details[open] {
            padding: 10px;
        }

        .advanced-section summary {
            cursor: pointer;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .advanced-section summary:hover {
            background: #e9ecef;
        }

        .advanced-section h3 {
            margin: 0;
            color: #666;
        }

        .advanced-section h4 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .console-section {
            margin: 30px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .console-section details[open] {
            padding: 10px;
        }

        .console-section summary {
            cursor: pointer;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .console-section summary:hover {
            background: #e9ecef;
        }

        .console-section h3 {
            margin: 0;
            color: #666;
        }

        .bootloader-instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .bootloader-instructions h4 {
            color: #856404;
            margin-top: 0;
        }

        .bootloader-instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        button {
            background-color: #d73502;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        button:hover:not(:disabled) {
            background-color: #b12d02;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .success {
            background-color: #28a745;
        }
        
        .success:hover:not(:disabled) {
            background-color: #218838;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #d73502;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .log {
            background-color: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        
        .warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 15px;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 15px;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .firmware-selector {
            margin: 15px 0;
        }

        .firmware-selector h4 {
            margin-bottom: 10px;
        }

        .firmware-selector input[type="file"] {
            margin: 10px 0;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            max-width: 400px;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¥ Teams Red Light - ESP32 Flasher</h1>
        
        <div class="info">
            <strong>Requirements:</strong>
            <ul>
                <li>Chrome or Edge browser (Web Serial API support required)</li>
                <li>ESP32 development board</li>
                <li>USB cable for connecting ESP32 to computer</li>
            </ul>
        </div>

        <!-- Version Information -->
        <div class="version-info">
            <h3>üîó Firmware Version</h3>
            <div id="versionDisplay">Loading version information...</div>
        </div>
        
        <!-- Main Actions -->
        <div class="main-actions">
            <h3>üöÄ Quick Flash</h3>
            <p>Flash the latest firmware to your ESP32 in just two steps:</p>
            
            <div class="action-buttons">
                <button id="connectBtn" onclick="connectToESP32()" class="primary-action">
                    üì± Connect to ESP32
                </button>
                <button id="flashBtn" onclick="startFlashProcess()" disabled class="primary-action">
                    ‚ö° Flash Latest Firmware
                </button>
                <button id="disconnectBtn" onclick="disconnectESP32()" class="hidden">Disconnect</button>
                <button id="resetBtn" onclick="resetESP32()" class="hidden">Reset ESP32</button>
            </div>
            
            <div id="connectionStatus"></div>
            
            <div class="progress hidden" id="flashProgress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div id="flashStatus"></div>
        </div>
        
        <!-- Advanced Options (Collapsible) -->
        <div class="advanced-section">
            <details>
                <summary><h3>‚öôÔ∏è Advanced Options</h3></summary>
                
                <div class="firmware-selector">
                    <h4>Custom Firmware</h4>
                    <p>For developers or advanced users who want to upload their own firmware:</p>
                    
                    <input type="file" id="customFirmware" accept=".bin">
                    <button onclick="loadCustomFirmware()" id="loadCustomBtn">Load Custom Firmware</button>
                    
                    <div id="customFirmwareStatus"></div>
                </div>
                
                <div class="bootloader-instructions">
                    <h4>Manual Bootloader Mode</h4>
                    <p>If automatic bootloader mode doesn't work:</p>
                    <ol>
                        <li>Hold the BOOT button on your ESP32</li>
                        <li>Press and release the EN/RST button</li>
                        <li>Release the BOOT button</li>
                        <li>Click "Flash Latest Firmware" above</li>
                    </ol>
                </div>
            </details>
        </div>

        <!-- Success Message -->
        <div class="step hidden" id="successStep">
            <h3>‚úÖ Setup Complete</h3>
            <p>Firmware has been flashed successfully! Your ESP32 is now ready to use.</p>
            
            <div class="info">
                <strong>Next Steps:</strong>
                <ol>
                    <li>The ESP32 will create a WiFi network called "Teams Red Light"</li>
                    <li>Connect to this network with password "configure"</li>
                    <li>Open a browser and go to http://192.168.4.1</li>
                    <li>Configure your WiFi and Microsoft Teams settings</li>
                </ol>
            </div>
            
            <button onclick="startOver()" class="success">Flash Another Device</button>
        </div>
        
        <!-- Console Output -->
        <div class="console-section">
            <details>
                <summary><h3>üìã Console Output</h3></summary>
                <div id="console" class="log"></div>
                <button onclick="clearConsole()">Clear Console</button>
            </details>
        </div>
    </div>

    <script>
        let port = null;
        let reader = null;
        let writer = null;
        let firmwareData = null;
        let latestVersion = null;
        let isCustomFirmware = false;

        // Check for Web Serial API support
        if (!('serial' in navigator)) {
            document.body.innerHTML = `
                <div class="container">
                    <h1>üî¥ Teams Red Light - ESP32 Flasher</h1>
                    <div class="warning">
                        <h3>Web Serial API Not Supported</h3>
                        <p>This flasher requires a browser that supports the Web Serial API.</p>
                        <p>Please use a recent version of Chrome or Edge browser.</p>
                        <p>Firefox and Safari are not currently supported.</p>
                    </div>
                </div>
            `;
        }

        function log(message) {
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString();
            console.textContent += `[${timestamp}] ${message}\n`;
            console.scrollTop = console.scrollHeight;
        }

        function clearConsole() {
            document.getElementById('console').textContent = '';
        }

        // Load version information on page load
        async function loadVersionInfo() {
            try {
                log('Loading firmware version information...');
                const response = await fetch('https://api.github.com/repos/fchapleau/teams-redlight/releases/latest');
                const data = await response.json();
                latestVersion = data;
                
                const versionDisplay = document.getElementById('versionDisplay');
                versionDisplay.innerHTML = `
                    <div style="font-size: 1.2em; font-weight: bold; color: #d73502;">
                        Latest Version: ${data.tag_name}
                    </div>
                    <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                        Released: ${new Date(data.published_at).toLocaleDateString()}
                    </div>
                    <div style="font-size: 0.9em; color: #666;">
                        Size: ${(data.assets.find(a => a.name.endsWith('.bin'))?.size / 1024 / 1024).toFixed(1)} MB
                    </div>
                `;
                
                log(`Latest firmware version ${data.tag_name} loaded`);
                
                // Pre-load the firmware data
                await downloadLatestFirmware();
                
            } catch (error) {
                log(`Error loading version info: ${error.message}`);
                document.getElementById('versionDisplay').innerHTML = `
                    <div style="color: #d73502;">Version information unavailable</div>
                    <div style="font-size: 0.9em; color: #666;">Using fallback firmware</div>
                `;
                // Fallback firmware
                firmwareData = new Uint8Array(1024 * 1024); // 1MB placeholder
                isCustomFirmware = false;
                log('Fallback firmware initialized (1MB placeholder)');
            }
        }

        async function downloadLatestFirmware() {
            if (!latestVersion) return;
            
            try {
                log('Loading firmware from GitHub Pages (same origin)...');
                
                // Fetch firmware from GitHub Pages (same origin) - no CORS issues
                const response = await fetch('./firmware/teams-redlight-firmware.bin');
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    firmwareData = new Uint8Array(data);
                    isCustomFirmware = false;
                    log(`Latest firmware loaded from GitHub Pages (${firmwareData.length} bytes)`);
                } else {
                    throw new Error(`Firmware not available (${response.status})`);
                }
            } catch (error) {
                log(`Error loading firmware: ${error.message}`);
                log('Using fallback placeholder firmware');
                // Fallback to placeholder firmware
                firmwareData = new Uint8Array(1024 * 1024); // 1MB placeholder
                isCustomFirmware = false;
            }
        }

        async function loadCustomFirmware() {
            const fileInput = document.getElementById('customFirmware');
            const file = fileInput.files[0];
            
            if (!file) {
                log('No custom firmware file selected');
                return;
            }
            
            try {
                const reader = new FileReader();
                reader.onload = function(e) {
                    firmwareData = new Uint8Array(e.target.result);
                    isCustomFirmware = true;
                    log(`Custom firmware loaded: ${file.name} (${firmwareData.length} bytes)`);
                    document.getElementById('customFirmwareStatus').innerHTML = `
                        <div style="color: #28a745; margin-top: 10px;">
                            ‚úÖ Custom firmware loaded: ${file.name} (${(firmwareData.length / 1024 / 1024).toFixed(1)} MB)
                        </div>
                    `;
                };
                reader.readAsArrayBuffer(file);
            } catch (error) {
                log(`Error loading custom firmware: ${error.message}`);
                document.getElementById('customFirmwareStatus').innerHTML = `
                    <div style="color: #d73502; margin-top: 10px;">
                        ‚ùå Error loading custom firmware: ${error.message}
                    </div>
                `;
            }
        }

        async function enterBootloaderMode() {
            if (!port) {
                throw new Error('No serial port connected');
            }
            
            try {
                // ESP32 bootloader entry sequence:
                // 1. Set DTR and RTS high (ESP32 running)
                // 2. Set DTR low (EN/RESET low - ESP32 in reset)
                // 3. Set RTS low (IO0 low - boot mode)
                // 4. Set DTR high (EN/RESET high - ESP32 starts in download mode)
                // 5. Set RTS high (IO0 high - normal operation)
                
                log('Setting DTR and RTS signals for bootloader mode...');
                
                // Step 1: Both high (normal operation)
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                await delay(100);
                
                // Step 2: DTR low (reset ESP32)
                await port.setSignals({ dataTerminalReady: false, requestToSend: true });
                await delay(100);
                
                // Step 3: RTS low (set boot mode)
                await port.setSignals({ dataTerminalReady: false, requestToSend: false });
                await delay(100);
                
                // Step 4: DTR high (release reset in boot mode)
                await port.setSignals({ dataTerminalReady: true, requestToSend: false });
                await delay(100);
                
                // Step 5: RTS high (normal IO0 operation)
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                await delay(500);
                
                log('ESP32 should now be in bootloader mode');
                
            } catch (error) {
                log(`Bootloader mode entry failed: ${error.message}`);
                throw error;
            }
        }

        async function connectToESP32() {
            try {
                // Check if already connected
                if (port && port.readable) {
                    log('Already connected to a serial port');
                    return;
                }
                
                // Ensure clean state before connecting
                if (port) {
                    await disconnectESP32();
                }
                
                log('Requesting serial port...');
                
                port = await navigator.serial.requestPort();
                
                // Use standard ESP32 serial configuration
                const serialOptions = {
                    baudRate: 115200,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none'
                };
                
                log('Opening serial port with standard ESP32 configuration...');
                await port.open(serialOptions);
                
                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                log('Connected to ESP32 at 115200 baud (8N1)');
                document.getElementById('connectBtn').classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');
                document.getElementById('flashBtn').disabled = false;
                document.getElementById('connectionStatus').innerHTML = '<div style="color: #28a745; margin: 10px 0;">‚úÖ Connected to ESP32</div>';
                
                // Start reading from serial port
                readSerial();
                
            } catch (error) {
                log(`Failed to connect: ${error.message}`);
                
                // Provide more specific error information
                let errorDetail = '';
                if (error.message.includes('Failed to open serial port')) {
                    errorDetail = ' - Port may be in use by another application or driver issue';
                } else if (error.message.includes('No port selected')) {
                    errorDetail = ' - No serial port was selected';
                }
                
                document.getElementById('connectionStatus').innerHTML = '<div style="color: #d73502; margin: 10px 0;">‚ùå Connection failed: ' + error.message + errorDetail + '</div>';
            }
        }

        async function disconnectESP32() {
            try {
                log('Disconnecting from ESP32...');
                
                // Proper cleanup sequence to prevent port-in-use errors
                if (reader) {
                    try {
                        await reader.cancel();
                    } catch (e) {
                        log(`Reader cancel error: ${e.message}`);
                    }
                    reader.releaseLock();
                    reader = null;
                }
                
                if (writer) {
                    try {
                        await writer.close();
                    } catch (e) {
                        log(`Writer close error: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (port) {
                    try {
                        await port.close();
                    } catch (e) {
                        log(`Port close error: ${e.message}`);
                    }
                    port = null;
                }
                
                log('Disconnected from ESP32');
                document.getElementById('connectBtn').classList.remove('hidden');
                document.getElementById('disconnectBtn').classList.add('hidden');
                document.getElementById('flashBtn').disabled = true;
                document.getElementById('connectionStatus').innerHTML = '';
                
            } catch (error) {
                log(`Error during disconnect: ${error.message}`);
                // Force cleanup even if there are errors
                reader = null;
                writer = null;
                port = null;
            }
        }

        async function readSerial() {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const text = new TextDecoder().decode(value);
                    log(`ESP32: ${text.trim()}`);
                }
            } catch (error) {
                log(`Serial read error: ${error.message}`);
            }
        }

        async function flashFirmwareToESP32(firmwareData) {
            const FLASH_WRITE_SIZE = 0x400; // 1024 bytes per write
            const FLASH_SECTOR_SIZE = 0x1000; // 4KB sectors
            const ESP32_FLASH_ADDRESS = 0x10000; // Standard app partition address
            
            try {
                log('Syncing with ESP32 bootloader...');
                await syncWithBootloader();
                
                log('Beginning firmware flash...');
                await beginFlash(firmwareData.length, ESP32_FLASH_ADDRESS);
                
                // Write firmware data in chunks
                const totalChunks = Math.ceil(firmwareData.length / FLASH_WRITE_SIZE);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * FLASH_WRITE_SIZE;
                    const end = Math.min(start + FLASH_WRITE_SIZE, firmwareData.length);
                    const chunk = firmwareData.slice(start, end);
                    
                    // Pad chunk to write size if needed
                    const paddedChunk = new Uint8Array(FLASH_WRITE_SIZE);
                    paddedChunk.set(chunk);
                    if (chunk.length < FLASH_WRITE_SIZE) {
                        paddedChunk.fill(0xFF, chunk.length); // Fill with 0xFF (erased flash state)
                    }
                    
                    await writeFlashData(ESP32_FLASH_ADDRESS + start, paddedChunk);
                    
                    const progress = ((i + 1) / totalChunks) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    
                    if (i % 10 === 0) { // Update progress less frequently
                        log(`Writing flash... ${Math.round(progress)}%`);
                    }
                }
                
                log('Finishing flash operation...');
                await finishFlash();
                
            } catch (error) {
                log(`Flash operation failed: ${error.message}`);
                throw error;
            }
        }

        async function syncWithBootloader() {
            // ESP32 sync command: 0x08 with specific payload
            const syncCmd = new Uint8Array([
                0xC0, // SLIP frame start
                0x00, 0x08, // Command: ESP_SYNC
                0x24, 0x00, 0x00, 0x00, // Data length: 36 bytes
                0x00, 0x00, 0x00, 0x00, // Checksum placeholder
                // Sync pattern (36 bytes)
                0x07, 0x07, 0x12, 0x20, 0x55, 0x55, 0x55, 0x55, 
                0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
                0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
                0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
                0x55, 0x55, 0x55, 0x55,
                0xC0 // SLIP frame end
            ]);
            
            // Send sync command multiple times for reliability
            for (let i = 0; i < 5; i++) {
                await writer.write(syncCmd);
                await delay(100);
            }
            
            log('Bootloader sync completed');
        }

        async function beginFlash(size, address) {
            const FLASH_WRITE_SIZE = 0x400; // 1024 bytes per write
            
            // ESP_FLASH_BEGIN command
            const beginCmd = new Uint8Array([
                0xC0, // SLIP frame start
                0x00, 0x02, // Command: ESP_FLASH_BEGIN
                0x10, 0x00, 0x00, 0x00, // Data length: 16 bytes
                0x00, 0x00, 0x00, 0x00, // Checksum placeholder
                // Data payload
                ...intToBytes(size, 4),    // Erase size
                ...intToBytes(Math.ceil(size / FLASH_WRITE_SIZE), 4),   // Number of blocks
                ...intToBytes(FLASH_WRITE_SIZE, 4), // Block size
                ...intToBytes(address, 4), // Flash address
                0xC0 // SLIP frame end
            ]);
            
            await writer.write(beginCmd);
            await delay(1000); // Allow time for flash erase
            log('Flash erase and begin completed');
        }

        async function writeFlashData(address, data) {
            // ESP_FLASH_DATA command
            const dataCmd = new Uint8Array([
                0xC0, // SLIP frame start
                0x00, 0x03, // Command: ESP_FLASH_DATA
                ...intToBytes(data.length + 16, 4), // Data length + header
                0x00, 0x00, 0x00, 0x00, // Checksum placeholder
                // Data header
                ...intToBytes(data.length, 4), // Data size
                ...intToBytes(0, 4),          // Sequence number (simplified)
                ...intToBytes(0, 4),          // Reserved
                ...intToBytes(0, 4),          // Reserved
                // Actual data
                ...data,
                0xC0 // SLIP frame end
            ]);
            
            await writer.write(dataCmd);
            await delay(50); // Small delay for write processing
        }

        async function finishFlash() {
            // ESP_FLASH_END command
            const endCmd = new Uint8Array([
                0xC0, // SLIP frame start
                0x00, 0x04, // Command: ESP_FLASH_END
                0x04, 0x00, 0x00, 0x00, // Data length: 4 bytes
                0x00, 0x00, 0x00, 0x00, // Checksum placeholder
                0x01, 0x00, 0x00, 0x00, // Reboot flag
                0xC0 // SLIP frame end
            ]);
            
            await writer.write(endCmd);
            await delay(500);
            log('Flash operation completed successfully');
        }

        function intToBytes(value, length) {
            const result = [];
            for (let i = 0; i < length; i++) {
                result.push((value >> (i * 8)) & 0xFF);
            }
            return result;
        }

        async function startFlashProcess() {
            if (!firmwareData) {
                log('No firmware data available');
                alert('No firmware loaded. Please try refreshing the page.');
                return;
            }

            if (!writer) {
                log('No connection to ESP32');
                alert('Please connect to ESP32 first');
                return;
            }

            try {
                const firmwareType = isCustomFirmware ? 'custom' : `latest (${latestVersion?.tag_name || 'unknown'})`;
                log(`Starting firmware flash (${firmwareType})...`);
                document.getElementById('flashProgress').classList.remove('hidden');
                document.getElementById('flashBtn').disabled = true;
                document.getElementById('flashStatus').innerHTML = '<div style="color: #0066cc;">üîÑ Flashing firmware...</div>';
                
                // Enter ESP32 bootloader mode using DTR/RTS signals
                log('Entering ESP32 bootloader mode...');
                await enterBootloaderMode();
                await delay(1000);
                
                // Actually flash the firmware to ESP32
                await flashFirmwareToESP32(firmwareData);
                
                log('Firmware flash completed successfully!');
                document.getElementById('flashStatus').innerHTML = '<div style="color: #28a745;">‚úÖ Firmware flashed successfully!</div>';
                document.getElementById('resetBtn').classList.remove('hidden');
                document.getElementById('successStep').classList.remove('hidden');
                
                // Scroll to success message
                document.getElementById('successStep').scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                log(`Flash error: ${error.message}`);
                document.getElementById('flashBtn').disabled = false;
                document.getElementById('flashStatus').innerHTML = '<div style="color: #d73502;">‚ùå Flash failed: ' + error.message + '</div>';
            }
        }

        async function resetESP32() {
            if (port) {
                try {
                    log('Resetting ESP32 using DTR signal...');
                    // Reset ESP32 by toggling DTR (EN/RESET line)
                    await port.setSignals({ dataTerminalReady: false, requestToSend: true });
                    await delay(100);
                    await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                    log('ESP32 reset signal sent');
                } catch (error) {
                    log(`Reset error: ${error.message}`);
                }
            }
        }

        async function sendCommand(command) {
            if (writer) {
                const data = new TextEncoder().encode(command + '\r\n');
                await writer.write(data);
                log(`Sent: ${command}`);
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function startOver() {
            // Reset UI to initial state
            document.getElementById('flashProgress').classList.add('hidden');
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('resetBtn').classList.add('hidden');
            document.getElementById('flashBtn').disabled = !firmwareData || !port;
            document.getElementById('successStep').classList.add('hidden');
            document.getElementById('flashStatus').innerHTML = '';
            document.getElementById('customFirmwareStatus').innerHTML = '';
            
            // Reset firmware to latest (not custom)
            if (!isCustomFirmware) {
                downloadLatestFirmware();
            }
            
            clearConsole();
            log('Ready to flash another device');
        }

        // Initialize
        loadVersionInfo();
        log('ESP32 Flasher ready - Latest firmware will be used by default');
        
        // Clean up serial connections when page unloads
        window.addEventListener('beforeunload', async () => {
            if (port) {
                try {
                    await disconnectESP32();
                } catch (error) {
                    console.log('Cleanup error:', error);
                }
            }
        });
    </script>
</body>
</html>