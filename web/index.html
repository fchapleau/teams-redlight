<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teams Red Light - ESP32 Flasher</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #d73502;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .step {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        
        .step h3 {
            color: #333;
            margin-top: 0;
        }
        
        .step.active {
            border-color: #d73502;
            background-color: #fff5f5;
        }
        
        .step.completed {
            border-color: #28a745;
            background-color: #f8fff8;
        }

        /* New simplified layout styles */
        .version-info {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .version-info h3 {
            color: #d73502;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .main-actions {
            background: #fff;
            border: 2px solid #d73502;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .main-actions h3 {
            color: #d73502;
            margin-top: 0;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .primary-action {
            background: linear-gradient(135deg, #d73502, #b12d02);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(215, 53, 2, 0.3);
        }

        .primary-action:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(215, 53, 2, 0.4);
        }

        .primary-action:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .advanced-section {
            margin: 30px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .advanced-section details[open] {
            padding: 10px;
        }

        .advanced-section summary {
            cursor: pointer;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .advanced-section summary:hover {
            background: #e9ecef;
        }

        .advanced-section h3 {
            margin: 0;
            color: #666;
        }

        .advanced-section h4 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .console-section {
            margin: 30px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .console-section details[open] {
            padding: 10px;
        }

        .console-section summary {
            cursor: pointer;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .console-section summary:hover {
            background: #e9ecef;
        }

        .console-section h3 {
            margin: 0;
            color: #666;
        }

        .bootloader-instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .bootloader-instructions h4 {
            color: #856404;
            margin-top: 0;
        }

        .bootloader-instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        button {
            background-color: #d73502;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        button:hover:not(:disabled) {
            background-color: #b12d02;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .success {
            background-color: #28a745;
        }
        
        .success:hover:not(:disabled) {
            background-color: #218838;
        }
        
        .progress {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #d73502;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .log {
            background-color: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            white-space: pre-wrap;
        }
        
        .warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 15px;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 15px;
            border: 1px solid #bee5eb;
            border-radius: 5px;
            margin: 15px 0;
        }
        
        .firmware-selector {
            margin: 15px 0;
        }

        .firmware-selector h4 {
            margin-bottom: 10px;
        }

        .firmware-selector input[type="file"] {
            margin: 10px 0;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100%;
            max-width: 400px;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¥ Teams Red Light - ESP32 Flasher</h1>
        
        <div class="info">
            <strong>Requirements:</strong>
            <ul>
                <li>Chrome or Edge browser (Web Serial API support required)</li>
                <li>ESP32 development board</li>
                <li>USB cable for connecting ESP32 to computer</li>
            </ul>
        </div>

        <!-- Version Information -->
        <div class="version-info">
            <h3>üîó Firmware Version</h3>
            <div id="versionDisplay">Loading version information...</div>
        </div>
        
        <!-- Main Actions -->
        <div class="main-actions">
            <h3>üöÄ Quick Flash</h3>
            <p>Flash the latest firmware to your ESP32 in just two steps:</p>
            
            <div class="action-buttons">
                <button id="connectBtn" onclick="connectToESP32()" class="primary-action">
                    üì± Connect to ESP32
                </button>
                <button id="flashBtn" onclick="startFlashProcess()" disabled class="primary-action">
                    ‚ö° Flash Latest Firmware
                </button>
                <button id="disconnectBtn" onclick="disconnectESP32()" class="hidden">Disconnect</button>
                <button id="resetBtn" onclick="resetESP32()" class="hidden">Reset ESP32</button>
            </div>
            
            <div id="connectionStatus"></div>
            
            <div class="progress hidden" id="flashProgress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div id="flashStatus"></div>
        </div>
        
        <!-- Advanced Options (Collapsible) -->
        <div class="advanced-section">
            <details>
                <summary><h3>‚öôÔ∏è Advanced Options</h3></summary>
                
                <div class="firmware-selector">
                    <h4>Custom Firmware</h4>
                    <p>For developers or advanced users who want to upload their own firmware:</p>
                    
                    <input type="file" id="customFirmware" accept=".bin">
                    <button onclick="loadCustomFirmware()" id="loadCustomBtn">Load Custom Firmware</button>
                    
                    <div id="customFirmwareStatus"></div>
                </div>
                
                <div class="bootloader-instructions">
                    <h4>Manual Bootloader Mode</h4>
                    <p>If automatic bootloader mode doesn't work:</p>
                    <ol>
                        <li><strong>Hold</strong> the BOOT button on your ESP32</li>
                        <li><strong>Press and release</strong> the EN/RST button (while still holding BOOT)</li>
                        <li><strong>Release</strong> the BOOT button</li>
                        <li><strong>Click</strong> "Flash Latest Firmware" above</li>
                    </ol>
                    <div style="background: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 5px; padding: 10px; margin: 10px 0;">
                        <strong>üí° Tips:</strong>
                        <ul style="margin: 5px 0 0 0; padding-left: 20px;">
                            <li>The BOOT button is usually labeled "BOOT", "IO0", or "FLASH"</li>
                            <li>The EN/RST button is usually labeled "EN", "RST", or "RESET"</li>
                            <li>Some ESP32 boards have different button layouts - check your board documentation</li>
                            <li>If you see chip ID 0x6465, this indicates the ESP32 is not in bootloader mode</li>
                        </ul>
                    </div>
                    <button onclick="showBootloaderHelp()" style="background: #007bff; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">
                        üîß Show Detailed Help
                    </button>
                </div>
            </details>
        </div>

        <!-- Success Message -->
        <div class="step hidden" id="successStep">
            <h3>‚úÖ Setup Complete</h3>
            <p>Firmware has been flashed successfully! Your ESP32 is now ready to use.</p>
            
            <div class="info">
                <strong>Next Steps:</strong>
                <ol>
                    <li>The ESP32 will create a WiFi network called "Teams Red Light"</li>
                    <li>Connect to this network with password "configure"</li>
                    <li>Open a browser and go to http://192.168.4.1</li>
                    <li>Configure your WiFi and Microsoft Teams settings</li>
                </ol>
            </div>
            
            <button onclick="startOver()" class="success">Flash Another Device</button>
        </div>
        
        <!-- Console Output -->
        <div class="console-section">
            <details>
                <summary><h3>üìã Console Output</h3></summary>
                <div id="console" class="log"></div>
                <button onclick="clearConsole()">Clear Console</button>
            </details>
        </div>
    </div>

    <script>
        let port = null;
        let reader = null;
        let writer = null;
        let firmwareData = null;
        let latestVersion = null;
        let isCustomFirmware = false;
        let remainingData = new Uint8Array(0);
        
        // Bootloader communication tracking
        let lastSyncResponseReceived = false;
        let lastChipIdValue = null;
        let chipIdResponseReceived = false;

        // Check for Web Serial API support
        if (!('serial' in navigator)) {
            document.body.innerHTML = `
                <div class="container">
                    <h1>üî¥ Teams Red Light - ESP32 Flasher</h1>
                    <div class="warning">
                        <h3>Web Serial API Not Supported</h3>
                        <p>This flasher requires a browser that supports the Web Serial API.</p>
                        <p>Please use a recent version of Chrome or Edge browser.</p>
                        <p>Firefox and Safari are not currently supported.</p>
                    </div>
                </div>
            `;
        }

        function log(message) {
            const console = document.getElementById('console');
            const timestamp = new Date().toLocaleTimeString();
            console.textContent += `[${timestamp}] ${message}\n`;
            console.scrollTop = console.scrollHeight;
        }

        function clearConsole() {
            document.getElementById('console').textContent = '';
        }

        // Load version information on page load
        async function loadVersionInfo() {
            try {
                log('Loading firmware version information...');
                const response = await fetch('https://api.github.com/repos/fchapleau/teams-redlight/releases/latest');
                const data = await response.json();
                latestVersion = data;
                
                const versionDisplay = document.getElementById('versionDisplay');
                versionDisplay.innerHTML = `
                    <div style="font-size: 1.2em; font-weight: bold; color: #d73502;">
                        Latest Version: ${data.tag_name}
                    </div>
                    <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                        Released: ${new Date(data.published_at).toLocaleDateString()}
                    </div>
                    <div style="font-size: 0.9em; color: #666;">
                        Size: ${(data.assets.find(a => a.name.endsWith('.bin'))?.size / 1024 / 1024).toFixed(1)} MB
                    </div>
                `;
                
                log(`Latest firmware version ${data.tag_name} loaded`);
                
                // Pre-load the firmware data
                await downloadLatestFirmware();
                
            } catch (error) {
                log(`Error loading version info: ${error.message}`);
                document.getElementById('versionDisplay').innerHTML = `
                    <div style="color: #d73502;">Version information unavailable</div>
                    <div style="font-size: 0.9em; color: #666;">Using fallback firmware</div>
                `;
                // Fallback firmware
                firmwareData = new Uint8Array(1024 * 1024); // 1MB placeholder
                isCustomFirmware = false;
                log('Fallback firmware initialized (1MB placeholder)');
            }
        }

        async function downloadLatestFirmware() {
            if (!latestVersion) return;
            
            try {
                log('Loading firmware from GitHub Pages (same origin)...');
                
                // Fetch firmware from GitHub Pages (same origin) - no CORS issues
                const response = await fetch('./firmware/teams-redlight-firmware.bin');
                if (response.ok) {
                    const data = await response.arrayBuffer();
                    firmwareData = new Uint8Array(data);
                    isCustomFirmware = false;
                    log(`Latest firmware loaded from GitHub Pages (${firmwareData.length} bytes)`);
                } else {
                    throw new Error(`Firmware not available (${response.status})`);
                }
            } catch (error) {
                log(`Error loading firmware: ${error.message}`);
                log('Using fallback placeholder firmware');
                // Fallback to placeholder firmware
                firmwareData = new Uint8Array(1024 * 1024); // 1MB placeholder
                isCustomFirmware = false;
            }
        }

        async function loadCustomFirmware() {
            const fileInput = document.getElementById('customFirmware');
            const file = fileInput.files[0];
            
            if (!file) {
                log('No custom firmware file selected');
                return;
            }
            
            try {
                const reader = new FileReader();
                reader.onload = function(e) {
                    firmwareData = new Uint8Array(e.target.result);
                    isCustomFirmware = true;
                    log(`Custom firmware loaded: ${file.name} (${firmwareData.length} bytes)`);
                    document.getElementById('customFirmwareStatus').innerHTML = `
                        <div style="color: #28a745; margin-top: 10px;">
                            ‚úÖ Custom firmware loaded: ${file.name} (${(firmwareData.length / 1024 / 1024).toFixed(1)} MB)
                        </div>
                    `;
                };
                reader.readAsArrayBuffer(file);
            } catch (error) {
                log(`Error loading custom firmware: ${error.message}`);
                document.getElementById('customFirmwareStatus').innerHTML = `
                    <div style="color: #d73502; margin-top: 10px;">
                        ‚ùå Error loading custom firmware: ${error.message}
                    </div>
                `;
            }
        }

        async function enterBootloaderMode() {
            if (!port) {
                throw new Error('No serial port connected');
            }
            
            try {
                // ESP32 bootloader entry sequence:
                // 1. Set DTR and RTS high (ESP32 running)
                // 2. Set DTR low (EN/RESET low - ESP32 in reset)
                // 3. Set RTS low (IO0 low - boot mode)
                // 4. Set DTR high (EN/RESET high - ESP32 starts in download mode)
                // 5. Set RTS high (IO0 high - normal operation)
                
                log('Setting DTR and RTS signals for bootloader mode...');
                
                // Step 1: Both high (normal operation)
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                await delay(100);
                
                // Step 2: DTR low (reset ESP32)
                await port.setSignals({ dataTerminalReady: false, requestToSend: true });
                await delay(100);
                
                // Step 3: RTS low (set boot mode)
                await port.setSignals({ dataTerminalReady: false, requestToSend: false });
                await delay(100);
                
                // Step 4: DTR high (release reset in boot mode)
                await port.setSignals({ dataTerminalReady: true, requestToSend: false });
                await delay(100);
                
                // Step 5: RTS high (normal IO0 operation)
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                await delay(500);
                
                log('ESP32 should now be in bootloader mode');
                
            } catch (error) {
                log(`Bootloader mode entry failed: ${error.message}`);
                throw error;
            }
        }

        async function connectToESP32() {
            try {
                // Check if already connected
                if (port && port.readable) {
                    log('Already connected to a serial port');
                    return;
                }
                
                // Ensure clean state before connecting
                if (port) {
                    await disconnectESP32();
                }
                
                log('Requesting serial port...');
                
                port = await navigator.serial.requestPort();
                
                // Use standard ESP32 serial configuration
                const serialOptions = {
                    baudRate: 115200,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none'
                };
                
                log('Opening serial port with standard ESP32 configuration...');
                await port.open(serialOptions);
                
                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                log('Connected to ESP32 at 115200 baud (8N1)');
                document.getElementById('connectBtn').classList.add('hidden');
                document.getElementById('disconnectBtn').classList.remove('hidden');
                document.getElementById('flashBtn').disabled = false;
                document.getElementById('connectionStatus').innerHTML = '<div style="color: #28a745; margin: 10px 0;">‚úÖ Connected to ESP32</div>';
                
                // Start reading from serial port
                readSerial();
                
            } catch (error) {
                log(`Failed to connect: ${error.message}`);
                
                // Provide more specific error information
                let errorDetail = '';
                if (error.message.includes('Failed to open serial port')) {
                    errorDetail = ' - Port may be in use by another application or driver issue';
                } else if (error.message.includes('No port selected')) {
                    errorDetail = ' - No serial port was selected';
                }
                
                document.getElementById('connectionStatus').innerHTML = '<div style="color: #d73502; margin: 10px 0;">‚ùå Connection failed: ' + error.message + errorDetail + '</div>';
            }
        }

        async function disconnectESP32() {
            try {
                log('Disconnecting from ESP32...');
                
                // Proper cleanup sequence to prevent port-in-use errors
                if (reader) {
                    try {
                        await reader.cancel();
                    } catch (e) {
                        log(`Reader cancel error: ${e.message}`);
                    }
                    reader.releaseLock();
                    reader = null;
                }
                
                if (writer) {
                    try {
                        await writer.close();
                    } catch (e) {
                        log(`Writer close error: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (port) {
                    try {
                        await port.close();
                    } catch (e) {
                        log(`Port close error: ${e.message}`);
                    }
                    port = null;
                }
                
                log('Disconnected from ESP32');
                document.getElementById('connectBtn').classList.remove('hidden');
                document.getElementById('disconnectBtn').classList.add('hidden');
                document.getElementById('flashBtn').disabled = true;
                document.getElementById('connectionStatus').innerHTML = '';
                
            } catch (error) {
                log(`Error during disconnect: ${error.message}`);
                // Force cleanup even if there are errors
                reader = null;
                writer = null;
                port = null;
            }
        }

        async function readSerial() {
            let buffer = new Uint8Array(0);
            
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    // Accumulate data in buffer
                    const newBuffer = new Uint8Array(buffer.length + value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(value, buffer.length);
                    buffer = newBuffer;
                    
                    // Process complete SLIP frames
                    buffer = processSlipFrames(buffer);
                    
                    // Also log as text for debugging (ESP32 might send text output)
                    const text = new TextDecoder().decode(value);
                    if (text.trim().length > 0) {
                        log(`ESP32: ${text.trim()}`);
                    }
                }
            } catch (error) {
                log(`Serial read error: ${error.message}`);
            }
        }

        function processSlipFrames(buffer) {
            let processed = 0;
            
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] === 0xC0) { // SLIP frame delimiter
                    if (i > processed) {
                        // Found a complete frame
                        const frameData = buffer.slice(processed, i);
                        if (frameData.length > 0) {
                            parseBootloaderResponse(frameData);
                        }
                    }
                    processed = i + 1;
                }
            }
            
            // Return remaining unprocessed data
            return buffer.slice(processed);
        }

        function parseBootloaderResponse(frameData) {
            if (frameData.length < 10) {
                return; // Too short to be a valid response
            }
            
            // Parse ESP32 bootloader response structure
            // [direction][command][size][value][status]
            const direction = frameData[0];
            const command = frameData[1] | (frameData[2] << 8);
            const size = frameData[3] | (frameData[4] << 8) | (frameData[5] << 16) | (frameData[6] << 24);
            
            if (command === 0x0A && size >= 4) { // READ_REG response
                const value = frameData[7] | (frameData[8] << 8) | (frameData[9] << 16) | (frameData[10] << 24);
                log(`Chip ID register read: 0x${value.toString(16).padStart(8, '0')}`);
                
                // Track chip ID response
                lastChipIdValue = value;
                chipIdResponseReceived = true;
                
                // Validate ESP32 chip ID
                if (isValidESP32ChipId(value)) {
                    log('‚úÖ Valid ESP32 chip detected');
                } else {
                    // Handle the specific case mentioned in the issue
                    if (value === 0x6465) {
                        log('‚ùå Detected chip ID 0x6465 - This indicates a communication protocol error');
                        log('üí° This usually means the ESP32 is not in bootloader mode');
                        log('üí° Try pressing the BOOT button or check the connection');
                    } else {
                        log(`‚ö†Ô∏è Unexpected chip ID: 0x${value.toString(16)} - May still be compatible`);
                    }
                }
            } else if (command === 0x08) { // SYNC response
                log('‚úÖ Bootloader sync response received');
                lastSyncResponseReceived = true;
            } else if (frameData.length >= 8) {
                // Log any other responses for debugging
                const statusByte = frameData[frameData.length - 1];
                if (statusByte !== 0) {
                    log(`‚ö†Ô∏è Bootloader command 0x${command.toString(16)} returned status: 0x${statusByte.toString(16)}`);
                }
            }
        }

        function isValidESP32ChipId(chipId) {
            // Known ESP32 chip IDs and variants
            const validChipIds = [
                0x00000000, // ESP32 chip revision 0
                0x00000001, // ESP32 chip revision 1
                0x00000002, // ESP32 chip revision 2
                0x00000003, // ESP32 chip revision 3
                0x0000FFFF, // ESP32-S2
                0x0000FFFE, // ESP32-S3
                0x0000FFFD, // ESP32-C3
            ];
            
            // Check if it's a known chip ID or if the upper bits suggest it's an ESP32
            return validChipIds.includes(chipId) || (chipId & 0xFFFF0000) === 0x00000000;
        }

        async function flashFirmwareToESP32(firmwareData) {
            const FLASH_WRITE_SIZE = 0x400; // 1024 bytes per write
            const FLASH_SECTOR_SIZE = 0x1000; // 4KB sectors
            const ESP32_FLASH_ADDRESS = 0x10000; // Standard app partition address
            
            try {
                log('Syncing with ESP32 bootloader...');
                await syncWithBootloader();
                
                log('Attaching SPI flash...');
                await attachSpiFlash();
                
                log('Beginning firmware flash...');
                await beginFlash(firmwareData.length, ESP32_FLASH_ADDRESS);
                
                // Write firmware data in chunks
                const totalChunks = Math.ceil(firmwareData.length / FLASH_WRITE_SIZE);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * FLASH_WRITE_SIZE;
                    const end = Math.min(start + FLASH_WRITE_SIZE, firmwareData.length);
                    const chunk = firmwareData.slice(start, end);
                    
                    // Pad chunk to write size if needed
                    const paddedChunk = new Uint8Array(FLASH_WRITE_SIZE);
                    paddedChunk.set(chunk);
                    if (chunk.length < FLASH_WRITE_SIZE) {
                        paddedChunk.fill(0xFF, chunk.length); // Fill with 0xFF (erased flash state)
                    }
                    
                    await writeFlashData(ESP32_FLASH_ADDRESS + start, paddedChunk);
                    
                    const progress = ((i + 1) / totalChunks) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    
                    if (i % 10 === 0) { // Update progress less frequently
                        log(`Writing flash... ${Math.round(progress)}%`);
                    }
                }
                
                log('Finishing flash operation...');
                await finishFlash();
                
            } catch (error) {
                log(`Flash operation failed: ${error.message}`);
                throw error;
            }
        }

        async function attachSpiFlash() {
            // SPI_ATTACH_REQ command to properly initialize SPI flash communication
            const attachData = [
                0x00, 0x00, 0x00, 0x00, // hspi_config_arg
                0x00, 0x00, 0x00, 0x00  // sspi_config_arg  
            ];
            
            const attachCmd = createCommand(0x0D, attachData); // ESP_SPI_ATTACH command
            
            await writer.write(attachCmd);
            await delay(100);
            log('SPI flash attachment completed');
        }

        async function syncWithBootloader() {
            // ESP32 sync pattern data (36 bytes)
            const syncData = [
                0x07, 0x07, 0x12, 0x20, 0x55, 0x55, 0x55, 0x55, 
                0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
                0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
                0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
                0x55, 0x55, 0x55, 0x55
            ];
            
            const syncCmd = createCommand(0x08, syncData); // ESP_SYNC command
            
            // Clear any pending data in the serial buffer
            await clearSerialBuffer();
            
            let syncSuccess = false;
            let chipIdValid = false;
            
            // Send sync command multiple times for reliability
            for (let i = 0; i < 10; i++) { // Increased attempts for better reliability
                await writer.write(syncCmd);
                await delay(100);
                
                // Check for sync response after a few attempts
                if (i >= 2 && i % 3 === 0) {
                    // Wait a bit longer and check if we got a response
                    await delay(300);
                    syncSuccess = lastSyncResponseReceived;
                    if (syncSuccess) {
                        log(`‚úÖ Bootloader sync successful after ${i + 1} attempts`);
                        break;
                    }
                }
            }
            
            if (!syncSuccess) {
                log('‚ö†Ô∏è No sync response received, proceeding with chip ID check...');
            }
            
            // Read chip ID to verify we're talking to a valid ESP32
            chipIdValid = await readChipIdWithRetry();
            
            if (!chipIdValid) {
                throw new Error('Failed to establish valid communication with ESP32 bootloader');
            }
            
            log('Bootloader sync and chip validation completed');
        }

        async function clearSerialBuffer() {
            // Try to read and discard any pending data in the serial buffer
            if (reader) {
                try {
                    const { value, done } = await Promise.race([
                        reader.read(),
                        new Promise(resolve => setTimeout(() => resolve({ value: null, done: true }), 100))
                    ]);
                    
                    if (value && !done) {
                        log('üìß Cleared pending serial data');
                    }
                } catch (error) {
                    // Ignore errors from buffer clearing
                }
            }
        }

        async function readChipIdWithRetry() {
            const maxAttempts = 5;
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                log(`üîç Reading chip ID (attempt ${attempt}/${maxAttempts})...`);
                
                try {
                    const isValid = await readChipId();
                    if (isValid) {
                        return true;
                    }
                    
                    // If we got invalid chip ID 0x6465, wait and retry
                    if (lastChipIdValue === 0x6465) {
                        log(`‚ö†Ô∏è Got invalid chip ID 0x6465 on attempt ${attempt}, retrying...`);
                        await delay(500);
                        continue;
                    }
                    
                } catch (error) {
                    log(`‚ùå Chip ID read attempt ${attempt} failed: ${error.message}`);
                    if (attempt < maxAttempts) {
                        await delay(300);
                    }
                }
            }
            
            return false;
        }

        async function readChipId() {
            // READ_REG command to get chip ID from EFUSE_RD_REG_BASE + 0x3FC (0x60008420 on ESP32)
            const chipIdRegister = 0x60008420; // ESP32 chip ID register
            
            const readRegData = intToBytes(chipIdRegister, 4);
            const readRegCmd = createCommand(0x0A, readRegData); // ESP_READ_REG command
            
            // Reset chip ID response tracking
            lastChipIdValue = null;
            chipIdResponseReceived = false;
            
            // Send the command multiple times to ensure we get a response
            for (let i = 0; i < 3; i++) {
                await writer.write(readRegCmd);
                await delay(200); // Wait for response
            }
            
            log('Chip ID read commands sent - waiting for response...');
            
            // Give more time for the chip ID response to be processed
            await delay(1000); // Increased wait time
            
            // Check if we received a valid response
            if (chipIdResponseReceived && lastChipIdValue !== null) {
                return isValidESP32ChipId(lastChipIdValue);
            }
            
            log('‚ùå No chip ID response received');
            return false;
        }

        async function beginFlash(size, address) {
            const FLASH_WRITE_SIZE = 0x400; // 1024 bytes per write
            
            // ESP_FLASH_BEGIN command data
            const beginData = [
                ...intToBytes(size, 4),    // Erase size
                ...intToBytes(Math.ceil(size / FLASH_WRITE_SIZE), 4),   // Number of blocks
                ...intToBytes(FLASH_WRITE_SIZE, 4), // Block size
                ...intToBytes(address, 4) // Flash address
            ];
            
            const beginCmd = createCommand(0x02, beginData); // ESP_FLASH_BEGIN command
            
            await writer.write(beginCmd);
            await delay(1000); // Allow time for flash erase
            log('Flash erase and begin completed');
        }

        async function writeFlashData(address, data) {
            // ESP_FLASH_DATA command data header + actual data
            const dataHeader = [
                ...intToBytes(data.length, 4), // Data size
                ...intToBytes(0, 4),          // Sequence number (simplified)
                ...intToBytes(0, 4),          // Reserved
                ...intToBytes(0, 4)           // Reserved
            ];
            
            const fullData = [...dataHeader, ...data];
            const dataCmd = createCommand(0x03, fullData); // ESP_FLASH_DATA command
            
            await writer.write(dataCmd);
            await delay(50); // Small delay for write processing
        }

        async function finishFlash() {
            // ESP_FLASH_END command data
            const endData = [
                0x01, 0x00, 0x00, 0x00 // Reboot flag
            ];
            
            const endCmd = createCommand(0x04, endData); // ESP_FLASH_END command
            
            await writer.write(endCmd);
            await delay(500);
            log('Flash operation completed successfully');
        }

        function intToBytes(value, length) {
            const result = [];
            for (let i = 0; i < length; i++) {
                result.push((value >> (i * 8)) & 0xFF);
            }
            return result;
        }

        function calculateChecksum(data) {
            // Simple checksum calculation for ESP32 bootloader protocol
            let checksum = 0xEF; // ESP32 initial checksum seed
            for (let i = 0; i < data.length; i++) {
                checksum ^= data[i];
            }
            return checksum;
        }

        function createCommand(cmd, data = []) {
            // Create properly formatted ESP32 bootloader command with checksum
            const header = [
                0xC0, // SLIP frame start
                ...intToBytes(cmd, 2), // Command (little endian)
                ...intToBytes(data.length, 4), // Data length (little endian)
            ];
            
            // Calculate checksum over the data only
            const checksum = data.length > 0 ? calculateChecksum(data) : 0xEF;
            const checksumBytes = intToBytes(checksum, 4);
            
            return new Uint8Array([
                ...header,
                ...checksumBytes,
                ...data,
                0xC0 // SLIP frame end
            ]);
        }

        async function startFlashProcess() {
            if (!firmwareData) {
                log('No firmware data available');
                alert('No firmware loaded. Please try refreshing the page.');
                return;
            }

            if (!writer) {
                log('No connection to ESP32');
                alert('Please connect to ESP32 first');
                return;
            }

            try {
                const firmwareType = isCustomFirmware ? 'custom' : `latest (${latestVersion?.tag_name || 'unknown'})`;
                log(`Starting firmware flash (${firmwareType})...`);
                document.getElementById('flashProgress').classList.remove('hidden');
                document.getElementById('flashBtn').disabled = true;
                document.getElementById('flashStatus').innerHTML = '<div style="color: #0066cc;">üîÑ Flashing firmware...</div>';
                
                // Progressive bootloader entry with fallback strategies
                await attemptFlashWithFallbacks();
                
                log('Firmware flash completed successfully!');
                document.getElementById('flashStatus').innerHTML = '<div style="color: #28a745;">‚úÖ Firmware flashed successfully!</div>';
                document.getElementById('resetBtn').classList.remove('hidden');
                document.getElementById('successStep').classList.remove('hidden');
                
                // Scroll to success message
                document.getElementById('successStep').scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                log(`Flash error: ${error.message}`);
                document.getElementById('flashBtn').disabled = false;
                document.getElementById('flashStatus').innerHTML = '<div style="color: #d73502;">‚ùå Flash failed: ' + error.message + '</div>';
                
                // Show manual bootloader instructions if automatic failed
                if (error.message.includes('0x6465') || error.message.includes('bootloader') || error.message.includes('communication')) {
                    showManualBootloaderInstructions();
                }
            }
        }

        async function attemptFlashWithFallbacks() {
            const maxAttempts = 3;
            
            // Strategy 1: Standard automatic bootloader entry
            log('üì± Attempting automatic bootloader entry...');
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    log(`Attempt ${attempt}/${maxAttempts}: Automatic bootloader entry`);
                    await enterBootloaderMode();
                    await delay(1000);
                    
                    // Test communication with ESP32
                    if (await testBootloaderCommunication()) {
                        log('‚úÖ Automatic bootloader entry successful');
                        await flashFirmwareToESP32(firmwareData);
                        return; // Success!
                    }
                } catch (error) {
                    log(`‚ö†Ô∏è Automatic attempt ${attempt} failed: ${error.message}`);
                    if (attempt < maxAttempts) {
                        await delay(1000); // Wait before retry
                    }
                }
            }
            
            // Strategy 2: Extended timing bootloader entry
            log('üì± Attempting extended timing bootloader entry...');
            try {
                await enterBootloaderModeExtended();
                await delay(2000);
                
                if (await testBootloaderCommunication()) {
                    log('‚úÖ Extended timing bootloader entry successful');
                    await flashFirmwareToESP32(firmwareData);
                    return; // Success!
                }
            } catch (error) {
                log(`‚ö†Ô∏è Extended timing attempt failed: ${error.message}`);
            }
            
            // Strategy 3: Request manual bootloader entry
            log('üì± Requesting manual bootloader entry...');
            const userConsent = await requestManualBootloaderMode();
            if (userConsent) {
                // Give user time to follow instructions
                await delay(3000);
                
                // Test communication after manual entry
                if (await testBootloaderCommunication()) {
                    log('‚úÖ Manual bootloader entry successful');
                    await flashFirmwareToESP32(firmwareData);
                    return; // Success!
                }
            }
            
            // All strategies failed
            throw new Error('Could not establish bootloader communication. Please ensure ESP32 is properly connected and try manual bootloader mode.');
        }

        async function testBootloaderCommunication() {
            try {
                log('üîç Testing bootloader communication...');
                await syncWithBootloader();
                return true;
            } catch (error) {
                log(`‚ùå Bootloader communication test failed: ${error.message}`);
                return false;
            }
        }

        async function enterBootloaderModeExtended() {
            if (!port) {
                throw new Error('No serial port connected');
            }
            
            try {
                log('Setting DTR and RTS signals for extended bootloader mode...');
                
                // Extended timing sequence with longer delays
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                await delay(200);
                
                await port.setSignals({ dataTerminalReady: false, requestToSend: true });
                await delay(200);
                
                await port.setSignals({ dataTerminalReady: false, requestToSend: false });
                await delay(200);
                
                await port.setSignals({ dataTerminalReady: true, requestToSend: false });
                await delay(200);
                
                await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                await delay(1000); // Longer final delay
                
                log('ESP32 extended bootloader entry completed');
                
            } catch (error) {
                log(`Extended bootloader mode entry failed: ${error.message}`);
                throw error;
            }
        }

        async function requestManualBootloaderMode() {
            return new Promise((resolve) => {
                // Create modal dialog for manual instructions
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 10px; max-width: 500px; text-align: center;">
                        <h3 style="color: #d73502; margin-top: 0;">üîß Manual Bootloader Mode Required</h3>
                        <p>Automatic bootloader entry failed. Please follow these steps:</p>
                        <ol style="text-align: left; margin: 20px 0;">
                            <li><strong>Hold</strong> the BOOT button on your ESP32</li>
                            <li><strong>Press and release</strong> the EN/RST button</li>
                            <li><strong>Release</strong> the BOOT button</li>
                            <li><strong>Click Continue</strong> below</li>
                        </ol>
                        <p style="font-size: 0.9em; color: #666;">The ESP32 should now be in bootloader mode and ready for flashing.</p>
                        <div style="margin-top: 20px;">
                            <button onclick="continueFlash()" style="background: #d73502; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-right: 10px; cursor: pointer;">
                                Continue Flash
                            </button>
                            <button onclick="cancelFlash()" style="background: #666; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                                Cancel
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                window.continueFlash = () => {
                    document.body.removeChild(modal);
                    delete window.continueFlash;
                    delete window.cancelFlash;
                    resolve(true);
                };
                
                window.cancelFlash = () => {
                    document.body.removeChild(modal);
                    delete window.continueFlash;
                    delete window.cancelFlash;
                    resolve(false);
                };
            });
        }

        function showManualBootloaderInstructions() {
            // Show the manual bootloader instructions section
            const advancedSection = document.querySelector('.advanced-section details');
            if (advancedSection) {
                advancedSection.open = true;
                document.querySelector('.bootloader-instructions').scrollIntoView({ behavior: 'smooth' });
            }
        }

        function showBootloaderHelp() {
            // Create detailed help modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                overflow-y: auto;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 600px; max-height: 80vh; overflow-y: auto; margin: 20px;">
                    <h3 style="color: #d73502; margin-top: 0;">üîß ESP32 Bootloader Mode - Detailed Help</h3>
                    
                    <h4>Common ESP32 Board Types:</h4>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <strong>ESP32-DevKitC / NodeMCU-32S:</strong><br>
                        ‚Ä¢ BOOT button on left side<br>
                        ‚Ä¢ EN button on right side<br><br>
                        
                        <strong>ESP32-WROOM / DOIT DevKit:</strong><br>
                        ‚Ä¢ BOOT button labeled "IO0" or "FLASH"<br>
                        ‚Ä¢ EN button labeled "RST" or "RESET"<br><br>
                        
                        <strong>ESP32-S2/S3 boards:</strong><br>
                        ‚Ä¢ Similar layout but may have different labels<br>
                        ‚Ä¢ Look for GPIO0 and EN/RST buttons
                    </div>
                    
                    <h4>Step-by-Step Instructions:</h4>
                    <ol style="line-height: 1.6;">
                        <li><strong>Identify the buttons:</strong> Find BOOT (sometimes labeled IO0, FLASH, or GPIO0) and EN/RST (sometimes labeled RESET or EN)</li>
                        <li><strong>Hold BOOT:</strong> Press and keep holding the BOOT button</li>
                        <li><strong>Reset while holding:</strong> While still holding BOOT, press and quickly release the EN/RST button</li>
                        <li><strong>Release BOOT:</strong> Now release the BOOT button</li>
                        <li><strong>Verify:</strong> The ESP32 is now in bootloader mode - try flashing again</li>
                    </ol>
                    
                    <h4>Troubleshooting:</h4>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>If you still get chip ID 0x6465:</strong><br>
                        ‚Ä¢ Check USB cable connection<br>
                        ‚Ä¢ Try a different USB port<br>
                        ‚Ä¢ Ensure the ESP32 has power (LED should be on)<br>
                        ‚Ä¢ Some boards require holding BOOT longer<br>
                        ‚Ä¢ Try the sequence 2-3 times
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="closeBootloaderHelp()" style="background: #d73502; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
                            Close Help
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            window.closeBootloaderHelp = () => {
                document.body.removeChild(modal);
                delete window.closeBootloaderHelp;
            };
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    window.closeBootloaderHelp();
                }
            });
        }

        async function resetESP32() {
            if (port) {
                try {
                    log('Resetting ESP32 using DTR signal...');
                    // Reset ESP32 by toggling DTR (EN/RESET line)
                    await port.setSignals({ dataTerminalReady: false, requestToSend: true });
                    await delay(100);
                    await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                    log('ESP32 reset signal sent');
                } catch (error) {
                    log(`Reset error: ${error.message}`);
                }
            }
        }

        async function sendCommand(command) {
            if (writer) {
                const data = new TextEncoder().encode(command + '\r\n');
                await writer.write(data);
                log(`Sent: ${command}`);
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function startOver() {
            // Reset UI to initial state
            document.getElementById('flashProgress').classList.add('hidden');
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('resetBtn').classList.add('hidden');
            document.getElementById('flashBtn').disabled = !firmwareData || !port;
            document.getElementById('successStep').classList.add('hidden');
            document.getElementById('flashStatus').innerHTML = '';
            document.getElementById('customFirmwareStatus').innerHTML = '';
            
            // Reset firmware to latest (not custom)
            if (!isCustomFirmware) {
                downloadLatestFirmware();
            }
            
            clearConsole();
            log('Ready to flash another device');
        }

        // Initialize
        loadVersionInfo();
        log('ESP32 Flasher ready - Latest firmware will be used by default');
        
        // Diagnostic function to test command creation (for debugging)
        function testCommandCreation() {
            log('Testing ESP32 bootloader command creation...');
            const syncData = [0x07, 0x07, 0x12, 0x20];
            const cmd = createCommand(0x08, syncData);
            log(`Sample SYNC command length: ${cmd.length} bytes`);
            log('‚úÖ Command creation system functional');
        }

        // Test command creation on page load (for validation)
        testCommandCreation();
        
        // Clean up serial connections when page unloads
        window.addEventListener('beforeunload', async () => {
            if (port) {
                try {
                    await disconnectESP32();
                } catch (error) {
                    console.log('Cleanup error:', error);
                }
            }
        });
    </script>
</body>
</html>